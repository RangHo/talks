#+title: Verdi: A Framework for Implementing and Formally Verifying Distributed Systems
#+author: Juhun Lee
#+date: <2025-04-04 Fri>
#+options: timestamp:nil toc:nil num:nil

#+reveal_head_preamble: <style>
#+reveal_head_preamble:   .reveal { word-break: keep-all; }
#+reveal_head_preamble:   .reveal hgroup p { font-size: var(--r-heading3-size); }
#+reveal_head_preamble: </style>

#+reveal_plugins: (highlight math)
#+reveal_talk_url: https://talking.rangho.me/paper-verdi/
#+reveal_title_slide: <hgroup><h1>%t</h1><p>%a</p></hgroup><p>%d</p>
#+options: reveal_width:"90%"

* Introduction

- Distributed System is essential to modern computing environment
  - Cloud computing
  - Serverless architecture
  - etc.
- Higher availability, but higher chance of inconsistency
- Complex structure \rightarrow very difficult to verify from ground up

  *Verdi* provides a simpler way to verify distributed systems.

* Background

- Distributed system :: Computer system where multiple computers inter-communicating over different networks.

  There are different types of distributed systems:

  1. Computers in a *redundant system* runs same software across the network (e.g. distributed DBMS).
  2. Some computers in a *client-server architecture* will be selected as the server, managing a list of clients.

** How distributed systems may fail

In general there are two ways a distributed system can fail:

1. *Network failure* where packets are reordered, duplicated, or dropped.
2. *Node failure* where a computer in the system crash, and possibly re-appear.

** How formal verification may help

Formal verification is known to produce extremely reliable system, regardless of its complexity.

1. C compilers
2. Operating systems

* Abstract

- Goal :: Create an easy method of implementing and verifying distributed systems.
- Challenge :: Due to its complex structure, writing a formal proof (or perform exhaustive testings) from scratch is extremely difficult.
- Solution :: Provide formally verified, composable /semantics/ that developers can use to implement verifyable (and verified) distributed systems.

* Methods

#+caption: The Verdi workflow.
#+name: fig:verdi-workflow
[[file:assets/verdi-workflow.png]]

We will use a simple single-shared lock service to illustrate the method.

** Step 1: specification

A Verdi programmer specifies the correct behavior of their system in terms of /traces/.

*Trace*: sequences of external input and output generated by nodes in the system.

\begin{align}
\newcommand{\concat}{\texttt{ ++ }}

\texttt{mutex}(\tau) := \quad & \tau_1 \concat \langle n_1, \texttt{Grant} \rangle \concat \\
& \tau_2 \concat \langle n_2, \texttt{Grant} \rangle \concat \\
& \tau_3 \rightarrow \langle n_1, \texttt{Unlock} \rangle \in \tau_2
\end{align}

** Step 2: implementation

Once the correct behavior is established, the programmer can implement an application that implements this behavior.

*** Step 2.1: inputs

#+begin_src coq
  HandleInp (n: Name) (s: State n) (inp: Inp) :=
    match n with
        | Server => nop
        | Agent n =>
            match inp with
                | Lock =>
                    send (Server, LockMsg)
                | Unlock =>
                    if s == true then (
                        s := false;;
                        send (Server, UnlockMsg))
#+end_src

*** Step 2.2: messages

#+begin_src coq
  HandleMsg (n: Name) (s: State n) (src: Name) (msg: Msg) :=
    match n with
        | Server =>
            match msg with
                | LockMsg =>
                    if s == [] then
                    send (src, GrantMsg);;
                    s := s ++ [src]
                | UnlockMsg =>
                    s := tail s;;
                    if s != [] then send (head s, GrantMsg)
                | _ => nop
        | Agent n =>
            match msg with
                | GrantMsg =>
                    s := true;;
                    output Grant
                | _ => nop
#+end_src

** Step 3: implementation verification

So far, the ~mutex~ property for the lock service application assumes a reliable network environment.

To prove that this property holds on all traces of the lock services applications:

1. prove an invariant about the reachable node and network states of the application;
2. relate these reachable states to the producible traces;
3. show that the previous two steps imply that ~mutex~ holds on all producible states.

** Step 4: verified system transformers

*Verified System Transformers(VST)* are built-in transformers in Verdi that transforms a verified system into a different verified system.

- Transmission transformer :: handles network faults (e.g. packet drop, duplication, etc.)
- Replication transformer :: handles node faults (e.g. crash of a machine, etc.)

Verdi ships with a number of standard fault tolerance methods, such as sequence number transformer.

** Step 5: runtime extraction

Since the lock service is formally verified with Verdi, the service can be extracted into a OCaml code from the Coq implementation.

The extracted code is linked with Verdi shim (written in OCaml) that provides network primitives and event loops.



* Network semantics

Verdi provides numerous formally verified network semantics to simulate real-world scenarios.

In Verdi, network semantics are defined as step relations on a /state of the world/.

NOTE: \( \leadsto \) symbol means that a system that satisfies some condition may transition to the state on the right.

** Single-node semantics

\[
\frac{_{}H_{\texttt{inp}} (\sigma, i) = (\sigma', o)}{(\sigma, T) \leadsto_{\texttt{s}} (\sigma', T \concat \langle i, o \rangle)}
\]

** Reordering semantics

Input

\[
\frac{H_{\texttt{inp}} (n, \Sigma[n], i) = (\sigma', o, P') \quad \Sigma' = \Sigma[n \mapsto \sigma']}{(P, \Sigma, T) \leadsto_{\texttt{r}} (P \uplus P', \Sigma', T \concat \langle i, o \rangle)}
\]

Deliver

\[
\frac{H_{\texttt{net}} (dst, \Sigma[dst], src, m) = (\sigma', o, P') \quad \Sigma' = \Sigma[n \mapsto \sigma']}{(\lbrace (src, dst, m) \rbrace \uplus P, \Sigma, T) \leadsto_{\texttt{r}} (P \uplus P', \Sigma', T \concat \langle i, o \rangle)}
\]

** Duplicating semantics

\[
\frac{p \in P}{(P, \Sigma, T) \leadsto_{\texttt{dup}} (P \uplus \lbrace p \rbrace, \Sigma, T)}
\]

** Dropping semantics

Drop

\[
\frac{}{(\lbrace p \rbrace \uplus P, \Sigma, T) \leadsto_{\texttt{drop}} (P, \Sigma, T)}
\]

Timeout

\[
\frac{H_{\texttt{tmt}} (n, \Sigma[n]) = (\sigma', o, P') \quad \Sigma' = \Sigma[n \mapsto \sigma']}{(P, \Sigma, T) \leadsto_{\texttt{drop}} (P \uplus P', \Sigma', T \concat \langle tmt, o \rangle)}
\]

** Node failure

Crash

\[
\frac{n \notin F}{(P, \Sigma, F, T) \leadsto_{\texttt{fail}} (P, \Sigma, \lbrace n \rbrace \cup F, T)}
\]

Reboot

\[
\frac{n \in F \quad H_{\texttt{rbt}} (n, \Sigma[n]) = \sigma' \quad \Sigma' = \Sigma[n \mapsto \sigma']}{(P, \Sigma, F, T) \leadsto_{\texttt{fail}} (P, \Sigma', F - \lbrace n \rbrace, T)}
\]

* Verified system transformers

It is extremely difficult to consider all fault models while developing a distributed system.

There are a number of standard techniques to ensure fault tolerance.

Verdi provides these techniques as *Verified System Transformers*.

** Correctness of verified system transformers

Each transformer \( T \) provides a ~transfer~ function that:

\begin{align}
\forall \Phi \forall S, & \texttt{holds} (\Phi, S, \leadsto_1) \rightarrow \\
& \texttt{holds} (\texttt{transfer} (\Phi), T(S), \leadsto_2)
\end{align}

The ~transfer~ function is reversible, allowing /backward simulation/ preserving the correctness.

** Sequence numbering transformer

This transformer adds "sequence numbers" to each data packets; i.e. it remembers the \( \langle \texttt{number}, \texttt{sender} \rangle \) pair.

** Ghost variable 

This transformer adds "ghost variables" to the model in order to assist in proof.

* Evaluation

In the Verdi repository, there is a simple key-value storage implementation called ~vard~.

#+caption: Verdi's ~vard~ compared to ~etcd~, an industry-standard key-value storage.
#+name: fig:verdi-performance
[[file:assets/verdi-performance.png]]

* Conclusion

- Verdi streamlines the development of formally verified distributed systems.
- If the initial implementation is verified, the fault-tolerant version is also verified.
- The performance hit from the OCaml runtime is negligible, considering the high availability environment.
